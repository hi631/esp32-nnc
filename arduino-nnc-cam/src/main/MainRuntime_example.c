// Copyright (c) 2017 Sony Corporation. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *WARNING*
// THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
// PLEASE DO NOT EDIT THIS FILE BY HAND!

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

#include "MainRuntime_inference.h"
#include "MainRuntime_parameters.h"

#ifndef _WIN32
extern void spiffs_init();
extern void spiffs_listdir();
#endif

float Reduce_and_cut(unsigned char bdp[], float *idbf){
	float maxdt = 0.0;
	int ws=160; //, hs=120; // Reduce (virtual) QQVGA (160x120) to 40x30 (1/4) and cut out a 28x28 image starting at 6,1
	int w,h;
        for( h=0; h<28; h++){
        	for( w=0; w<28; w++){
            	int hh=(h+1)*4; int ww=(w+6)*4; // Dot position on screen size 160x120
                int d4s=(bdp[hh*ws+ww] + bdp[hh*ws+ww+2] + bdp[(hh+2)*ws+ww] +bdp[(hh+2)*ws+ww+2]) / 4; // Take an average of 4
                float dt=d4s; dt=dt/256;         // range from 0.00 to 0.99 with fload
                idbf[h*28+w]= dt;               // Store in input location
            	if(dt>maxdt) maxdt=dt;
            }
	}
        return(maxdt);
}

void set_brightness(float *idbf, float maxdt){
    float lil,lir,rd,aj;
    int h;
	for( h=0; h<28; h++){
   		lil=idbf[h*28+0]; lir=idbf[h*28+27];
   		for(int w=0; w<28; w++){
            aj=(lir-lil)/27*w+lil;
			rd=idbf[h*28+w];
            rd=(rd-aj)*(maxdt/(1.0-aj));
            if(rd<0.1) rd=0.0;
            idbf[h*28+w]=rd;
            //int ri=rd*255; printf("%d,", ri);
        }
        //printf("\n");
    }
}

void dispimage2text(float *idbf){
	char ch;
	for(int h=0; h<28; h++){
      	for(int w=0; w<28; w++){
		float f=idbf[h*28+w];
            if(f>0.8) f=1.0; else f=0.0;
            idbf[h*28+w]=f;
            if(f>0.5) ch='O'; else ch='.';
            printf("%c", ch);
      	}
        printf("\n");
    }
}

void move2center(float *idbf){
	// Calculate center
	int sx = 0, sy = 0, mm = 0;
	int h, w;
    for( h = 0; h < 28 ; h++ ) {
		for ( w = 0 ; w < 28 ; w++ ) {
        	float rd=idbf[h*28+w];
			if ( rd != 0.0 ) { sx += w; sy += h; ++mm; }
		}
	}
	int mtx = (float)sx/(float)mm+0.5-14;
	int mty = (float)sy/(float)mm+0.5-14;
	printf( "Pos= %d %d\n", mtx, mty );
    // move center
    float *wdbf = malloc( sizeof(float)*28*28 ); 
    memcpy(wdbf,idbf,sizeof(float)*28*28);
    memset(idbf,0,sizeof(float)*28*28);
    int mx,my;
    for( h = 0; h < 28 ; h++ ) {
		for ( w = 0 ; w < 28 ; w++ ) {
        	mx=mtx+w; my=mty+h;
            if(mx>-1 && my>-1 && mx<28 && my<28) idbf[h*28+w]=wdbf[my*28+mx];
		}
    }
    free( wdbf );
}

int nnc_main(unsigned char bdp[]) // bdp[] = 160x120 1byte (QQVGA GRAYSCALE)
{
		// Allocate and initialize context
		void *context = nnablart_mainruntime_allocate_context(MainRuntime_parameters);

		// Input Cam Data.
		float *idbf = nnablart_mainruntime_input_buffer(context, 0); // Input.Data.Buffer

		// Reduce (40x30) and cut out (28x28) the image (160x120)
		float maxdt = Reduce_and_cut(bdp, idbf);

		// Correct the brightness
        set_brightness(idbf, maxdt);

		//Move to the center
        move2center(idbf);

		// Display of image (28x28) to text
		dispimage2text(idbf);

		// Exec inference
		nnablart_mainruntime_inference(context);

		// Display Output
		float *odbf = nnablart_mainruntime_output_buffer(context, 0); // Output>data.buffer
		float maxd = -99; int maxp = 0;
		for (int j = 0; j < 10; j++) {
			printf(" %+3.3f", odbf[j]);
			if (odbf[j] > maxd) { maxd = odbf[j]; maxp = j; }
		}
		printf(" ( %d )\n", maxp);


		// free all context
		nnablart_mainruntime_free_context(context);

	return 0;
}
